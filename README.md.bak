# vue-element-web
前后端代码开发，包含真正的JWT前后端验证，前端动态路由管理，对epub文件增删改查处理等等
# 学习的想法和感受
**前端**
-vue-element-admin vuex axios
> 这个框架基本满足大部分管理平台的需求，优点和亮点：自带前端捕获异常工具，前端化的低成本鉴权机制，丰富的内建代码库，可以看出来，这个框架的作者真的很厉害

**后端**
-nodejs express Nginx https证书 Nginx内网穿透 mysql switchhost
> 基于https服务，上传下载，本地部署Nginx静态服务，线上采用阿里云申请的https证书的网页，内网穿透直接把本机的特定端口暴露于公网中，直接成为一台服务器，
> mysql8 和 2.18.1"的nodemysql无法匹配兼任问题解决
> switchhost对本机的环境进行改变，达到一台电脑能同时切换各种开发环境，保证代码编写效率最大化

**路由适配**
> 采用后端返回 router列表 前端拿到后对数据进一步处理，改造为符合 v-router的形式，最后 addRouter进主干代码
> 在全局的permission.js 中修改 router.beforeEach 代码，加入action，让vuex去负责修改代码并且生产set_router，最后返回的主干
> 直接commit到v-router上面，实现后端对前端登录后用户动态url，缺点：后端对该角色的鉴权是写死的，需要动态规划，或者给该用户
> 一个超级管理权限，否则就直接安装该角色配置动态视图，后端数据库查询该角色权限，动态生成视图返回给前端，这样业务产生大的变动，也
> 只是修改数据库，不影响后端代码的实现，该功能在后续更新中会逐一实现

**https的申请，域名注册，内网穿透的具体实现技巧**

-https申请和备案流程直接安装阿里云官方等等走，我这里只讨论阿里的套路，和我本人的应对
-阿里云：便宜点卖个域名给你6块钱一年行不行？可以
-阿里云：你买了域名但是本地无法开发，再买个服务器行不行？不行，我修改了本地host文件利用swithhost，把本机的地址解析为买的6块钱域名并且在安全组配置了 本机公网的端口，开放这个端口我自己用。
> 要理解：真正的线上环境是什么。线上环境就是一个个的Nginx类似的服务器，腾讯和阿里是定制的，我们就是个人版即可。Nginx返回域名下的
> 一个文件夹，你把项目丢到config配置的路径里面，新建admin，再把dist文件丢到admin里面，再通过浏览器打开当前文件目录即可。这就是后端上线的流程
> 一点也不难，但是要修改路径，对index路径修改到能找到为主即算是线上环境，然后再对此进行自测和开发，一个项目需要在各种环境下面的测试才是靠谱的项目
-阿里云：你买了域名，本机虽然能代理，但是还是局域网，就你电脑能这样做，其他，比如你手机就访问不了，得找李经理去买服务器，这里有一个月，一周按量付费.
-我：奇技淫巧，内网穿透，代理到公网，一个月10块钱，https连证书都不要，薅资本主义的羊毛就是这么炫酷，实现手段保密。
-阿里云：域名6块钱卖你便宜了

# 加密实现流程
登录功能：重难点，可以说掌握了这个流程的前端工程师，已经不是小白了，是中级工程师
> 登录流程：用户输入用户名，密码，对这里进行一次匹配检测，最少输入多少字符等等，发送到后端，后端验证后，前端的全局axios拦截
> request，切到登录后的页面，即算是完成了一次简易登录，注意：这样的登录毫无安全性可言，服务器极其容易遭受攻击
> 前端必须要的安全性科普：可以看我另外一篇文章 https://github.com/webarserker/webarserker-typescrpit-axios 是本人不才，跟着
> 前滴滴前端开发，现zoom前端开发黄奕老师走的流程，懂了很多新奇的玩意。包括csrf攻击等等。这里不谈大的，就谈前端和后端怎么修改请求头
> 搞定加密传输。

前端加密流程：这个不懂，永远不成大器。jsonwebtoken这个插件，配合这个网站https://jwt.io/ 当然，要科学上网，虽然最近越来越严了

> 后端先在 \vue-element-node\router\jwt.js 这个文件里面生成一个密室丢通过login给前端，由于白名单是给到了login，所以用户不需要一开始
> 就走进死循环，没有密匙就登录不了，先有鸡还是先有蛋。
> 用户登录成功后，getlogin 直接返回用户的 token给前端去存储到cookie，设定的是一小时过期时间，这些都是后端做，虽然前端能做，但是后端
> 有些东西就是应该在后端做好
> 正常的逻辑是：前端是展示项目的容器，而后端是控制项目的管理员，前端带token到后端，后端验证每一次请求的token，返回各种数据
> 尽量做好前后端边界的认识，对前端的提升是巨大的

后端加密流程:

> 后端uitls文件夹下方constant.js先定一个PRTVATE_KEY密匙，然后uitls/index.js 里面decoded这里通过规范，jwt必须以Bearer开头，否则你就
> 别传，后端解析不了的。前端在D:\vue小慕书\templete\vue-element-admin\src\components\EbookUpload\index.vue 里面的Authorization：`Bearer ${getToken()}`
> 以及D:\vue小慕书\templete\vue-element-admin\src\utils\request.js 对全局请求都加上这个config.headers['Authorization'] = `Bearer ${getToken()}` 
> 这里来讲讲全局请求拦截的好处：一处修改，处处可用，保证前端每一个请求都带了这个jwt验证，虽然有些项目或者页面，按钮后端不需要这个jwt验证，可以添加白名单，
> 这里是登录页面发送的请求就是白名单：D:\vue小慕书\templete\vue-element-node\router\jwt.js ；最新的expressJwt需要加入指定类型的算法algorithms: ['HS256'],
> 否则会报错，使用不了，这个npm包也支持很多种加密算法，这里是HS256算法，100年可以破解我的密码，天河计算机只要2年，比特币的总服务器估计2天吧，量子计算器
> 谷歌说只要3分钟，反正这个级别的加密很难破解。
	
# 功能环节

功能一：上传图书功能：
基本逻辑：用户点击上传，后端拿到前端传入的epub电子书（这里只能传epub），后端通过epub.js 进行解析出该图书的类型信息，
包括，作者，页码，封面，语言，书名，文件名称，出版社，并存入数据库和静态Nginx部署的文件目录。前端拿到后端接口返回的数据，利用
vue渲染表格达到数据解析。
-难点：
> 1.前端表格要对应做规则匹配，文件名称不能为空或者 必须传入那种字符，或者能不能编辑
> 2.封面对于epubjs来说，由于该库比较老旧，所以修改了该库的源码getImage 添加了解析xml中cover字段功能，保证应对绝大部分epub文件，网路上有很多转换格式的网站生成的epub虽然能解，但是路径修改的面目全非，这里就体现出这个修改的好处了
> 3.目录解析：后端直接出epub库解析出来的文件目录并不适合前端 elementUI目录结构，需要在后端查询转换数据格式然后返回给前端渲染生成，这一步放到后端完成，前端做的话会很卡，甚至抛出异常
> 4.新增图书功能：连接Nginx，利用的是https请求，对config配置为支持所有服务器访问，没有做局域网限制，但是在后续开发中需要设定一个局域网，只对公司内部开放服务，这样安全性很高。基本逻辑：不管数据库有没有该书，先上传，解析，然后等待用户提交，用户单击提交功能后，先去查询一次数据库有没有同名数据，对出版社，作者，书名，三个字段做匹配，确保真的没有。
	if(有该数据) { 
		直接抛出给异常通过boombadRequest，前端拿到该异常数据接口返回的msg，提升给用户，vue-element-admin确实好用，是默认捕获错误，
		我们不需要多写什么,但是只是捕获错误，真正的准确的错误提升在后端是全局兜底模块router/index.js 最下方利用boom生成 序列化的错误代码
		可以说，前后端项目就是利用错误进行沟通，一堆边界问题，并不是只靠前端或者后端对逻辑的处理，还要考兜底报错来告诉用户，不要这样做。
		然后删除Nginx什么的缓存数据，数据库缓存数据。	
	} else {
		没有就不删除服务端数据，保存，并且返回成功提升给前端，采用的饿了么UI的 $notify 生成一个标签，来给用户提升，提高用户体验，这时候
		可以去看看竞争的产品是怎么提升的，照着做准没错
	}
		

功能二:电子书列表：
基本逻辑：从后端getlist，getcategory，拿到数据和分类，丢到前端直接去渲染，由于是前端modul绑定数据，很方便的完成了渲染工作
难点一：前端书名，作者，分类的联合查询
> 1.为了优化用户体验，在查询书名，作者后，会自动高亮显示查询到的字段，采用正则ig匹配全字段的模式，保证不会出现只匹配第一个，而后面却没有的问题
> 2.模糊查询，书名和作者都是模糊查询对象，直接于后端对于数据库 where like 查询模糊匹配，由于mysql的like 不传字段就默认不查询，则不用写边界代码，很方便。对于后端数据库来说，我们传入的每一个字段都可能是关键字，所以对于每个查询语句都要采用 `` 反飘号去把字段特殊化。
> 3.对表格优化
v-router代码是采取节约性能模式，即：对浏览器地址url的设置不管你怎么修改都是不重新渲染页面组件，好处：节约性能，防止用户
改来改去，导致内存溢出。缺点：调试不方便，需要每次F5刷新，其实也没啥。然后绑定数据，绑定pagination组件，这个是vue-element-admin二次封装过的代码
很方便。

前端化思路在这里就产生了质变：URL优化。以往的前端都是把数据丢到cookie或者session里面，但是其实可以把数据直接push到url里面用路由
保存前端数据值，然后用户的操作发送请求，都是对url修改，让aixos直接带上用户的url到后端去请求数据，非常的方便快捷，可以说这点不通，前端永远是小白
		
4.我司旧项目数据库地址不同，数据格式不通用，但是想上我这里的平台怎么办？
一个独当一面的前端开发当然会兼容的，先链接数据库看看关键数据在不在，然后根据数据利用fs.read查询该路径下的文件是否存在，然后搜索到
返回给后端，后端拿到查询编排即可。但是问题是，有些项目格式名称都不对的文件，只能建议修改数据库，不然你直接自己写一个能解析epub的文件重新搞，没空就没写了
写了肯定有提升。而且，改数据库，也就一个上午的时间，可以写算法去sql，不需要太麻烦
	
	功能三：待续，后续写完会有自己的感悟